# THIS IS THE LML DEFAULT CONFIGURATION! IT GIVES AN EXAMPLE FOR ALL
# CONFIGURATION ITEMS THAT LML KNOWS.
#
# PLEASE DON'T EDIT THIS FILE!!!!!
#
# INSTEAD, CREATE ADDITIONAL CONFIGURATION FILES LIKE /etc/lml/*.conf
#
[dhcp]
# trigger the DHCP server with this command after changing the host list
triggercommand=sudo /usr/sbin/service dhcp3-server force-reload
# this file is managed by lml and contains ISC dhcp3 host entries for each managed host
hostsfile=/etc/dhcp3/dhcp-hosts.conf
# this is the domain we need to append to the VM name to construct a valid FQDN
appenddomain=arc.int
# NOTE: DNS is managed entirely through the DHCP integration, hence no configuration items here.

[gui]
# The GUI should filter the VM path, () denotes the part displayed to the user
# this removes the leading <datacenter-name>/vm>/ stuff from the display name
display_filter_vm_path=^[^/]+/vm/(.*)$

[pxelinux]
# redirect target if a VM passes all LML checks and is allowed to boot.
# think twice before changing this as pxelinux.0 uses that as a built-in default in case pxelinux.pl throws a 500
# set to 0 to disable redirecting
default_redirect=pxelinux.cfg/default
# redirect target for non-VMs (anything that LML can't find in the vSphere inventory)
# set to 0 to disable redirecting
unknown_redirect=pxelinux.cfg/default
# redirect target for VMs that don't match our networks
# set to 0 to disable redirecting
othervm_redirect=pxelinux.cfg/default

# pxelinux configuration for error screen
error_main= <<EOF
menu width 80
menu color title        * #FFFFFFFF *
menu color border       * #00000000 #00000000 none
menu color sel          0 #ffffffff #00000000 none
menu color unsel        0 #ffffffff #00000000 none
menu color hotsel       0 #ffffffff #00000000 none

menu vshift 5
#menu rows 13

ui vesamenu.c32
noescape 1
allowoptions 0
prompt 0
timeout 0

EOF
# pxelinux configuration error tile prefix for error screen
error_title=ERROR REPORT FOR VM
# pxelinux configuration for error item on error screen
error_item= <<EOF
        kernel reboot.c32
        text help
Please fix these issues and press ENTER to reboot and try again
        endtext
EOF

# template for qrdata forceboot target, URL will be replaced with the URL to the QR image
qrdata_template=<<EOF
# push the menu out of the screen
menu vshift -1
menu width 80
menu background URL
menu color title        * #FFFFFFFF *
menu color border       * #00000000 #00000000 none
menu color sel          0 #ffffffff #00000000 none
menu color unsel        0 #ffffffff #00000000 none
menu color hotsel       0 #ffffffff #00000000 none

menu vshift 5
#menu rows 13

label dummy
        menu label 
        kernel bin/reboot.c32

ui vesamenu.c32
noescape 1
allowoptions 0
prompt 0
timeout 0
EOF

# template for fatal errors. MESSAGE will be replaced by the actual error message. Used with showfatalerrors=1
# set a force boot target of fatalerror to trigger a fatal error for testing purposes
fatalerror_template=<<EOF
menu width 80
menu color title        * #ff000000 #ffffffff
menu color border       * #00000000 #00000000 none
menu color sel          * #ff000000 #ffffffff none
menu color unsel        * #ff000000 #ffffffff none
menu color hotsel       * #ff000000 #ffffffff none
menu color help         * #ff000000 #ffffffff none
menu vshift 5
menu title A FATAL ERROR HAS HAPPENED
menu rows 2

ui vesamenu.c32
noescape 1
allowoptions 0
prompt 0
timeout 0

label error
	menu label MESSAGE
        kernel reboot.c32
        text help
Please stand up and call for help!
        endtext

EOF

# local path to pxelinux.cfg directory, needed for forceboot autodetection
# This is the local path for the URI given to pxelinux as TFTP path prefix
# don't include the pxelinux.cfg directory itself!
pxelinuxcfg_path=/var/www/boot

[forceboot]
# force boot profiles
# NOTE: fatalerror is used internally, but you can override it at the loss of the ability to trigger a fake fatal error
# each profile simply maps to a pxelinux configuration file, for example:
# server=menu/server.centos5.txt

[hostrules]
# hostnames must match this Perl pattern
pattern=^[a-z]{6}[0-9]{3}$
# check hostnames also in the following domains to prevent conflicts. Never list DHCP.APPENDDOMAIN here!
dnschecknew=1
dnscheckzones= <<EOF
some.zone
some.other.zone
EOF

[modifyvm]
# modify the VM so that it can boot only via PXE
forcenetboot=1

[lml]
# where to keep lml internal data
datadir=/var/lib/lml
# should fatal errors be shown to the PXE boot client, this uses the fatalerror_template
# fatalerror is a builtin force boot target to trigger a fatal error for testing purposes
showfatalerrors=0
# should we fail on invalid forceboot targets
failoninvalidforceboot=1

[vmscreenshot]
# enable vmscreenshot.pl
enabled=1
# allow server_push
server_push=1
# how long to wait between pushing images
push_delay=15
# how many images to push in a single request (push_delay * push_max = Amount of time you can watch a VM)
push_max=25

[vsphere]
server=devvcs01.iscout.local
username=vCenterService
password=********************
# if you run this on VMA or on Windows then you can try to use pass through auth.
# However, this is an untested feature and might not work.
passthroughauth=0
# disable certificate checking
disablecertificatevalidation=0
# limit LML to handle only VMs that have a NIC in the following network names
# the names can be also a perl regex (^ and $ is added, don't use them!)
networks=<<EOF
arc.int
EOF
# define the custom field name that contains a UNIX username to validate
contactuserid_field=Contact User ID
# the UNIX username must have a uid >= this one
contactuserid_minuid=1000
# define the custom field name that contains the VM expiry date
expires_field=Expires
# use european date format for expiry date field
expires_european=1
# Define a field that contains info about forced PXE boots (ON|OFF)
forceboot_field=Force Boot
# Define a field where the target for the forceboot is given
forceboot_target_field=Force Boot Target

[http]
# here you can set some options for http
# base_url= can be set to the http://<host>/<path> that should be prefixed to all LML scripts
# if it is not set, then LML will try to guess it.
